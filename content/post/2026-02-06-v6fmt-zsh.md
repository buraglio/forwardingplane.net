---
title: IPv6 address formatting
date: 2026-02-06
author: Nick Buraglio
layout: post
categories:
    - ipv6
    - unix
tags:
    - ipv6
    - nix4neteng
---

IPv6 has a monumental amount of flexibility. That flexibility flow over into the address format, which can be - in some cases - a bit frustrating. Since IPv6 address can be presented in several ways, and this can be frustrating for those writing code to suport IPv6 or engineers trying to create templates. It can also be painful during troubleshooting. In an effort to craft something that is similar to my [mac address shell tool](https://www.forwardingplane.net/configuration-archive/useful-zsh-recipes-for-network-engineers/), I wanted something similar for IPv6 addresses.

Remembering that my programming skills are not teriffic, and all self-taught (ok, I leanred some Apple Basic in the 80s, some C in college, and used Perl in the "olden days") This proved the rule that developing for all permutations of a valid IPv6 address can be somewhat daunting.

After a lot of attempts this is what works:

```
┌─[buraglio@heelflip] - [~] - [3916]
└─[$] v6fmt 3fff:0209:0001:0000:0000:0000:0000:0001
Expanded: 3fff:0209:0001:0000:0000:0000:0000:0001
Canonical: 3fff:209:1::1
Permutations:
  3fff:209:1:0:0:0:0:1
  3fff:209:1::0:0:1
  3fff:209:1::0:1
  3fff:209:1::1
```

and

```
┌─[buraglio@heelflip] - [~] - [3917]
└─[$] v6fmt 3fff:209:1::1  
Expanded: 3fff:0209:0001:0000:0000:0000:0000:0001
Canonical: 3fff:209:1::1
Permutations:
  3fff:209:1:0:0:0:0:1
  3fff:209:1::0:0:1
  3fff:209:1::0:1
  3fff:209:1::1
```

Even this seemingly simple bit of text wrangling was painful. there are probably better ways to do this, and likely more simple tools, but I wanted this to be part of my operating shell, so here we are. Add this into your `.zshrc` and it should work. I am unsure if it works with bash, but I suspect because of the parameter expansion flags, globbing, and array work that is unique to zsh, it likely will not.  

```
v6fmt() {
  local ip="$1"
  
  [[ -z "$ip" ]] && { print -r -- "Usage: v6fmt <ipv6-address>" >&2; return 1 }
  
  # Normalize
  ip="${ip:l}"
  ip="${ip//[[:space:]]}"
  
  # Manual :: expansion
  local prefix suffix zeros_needed full_ip i g
  if [[ "$ip" == *::* ]]; then
    prefix="${ip%%::*}"
    suffix="${ip#*::}"
    
    # Count non-empty groups
    local pre_count=0 suf_count=0
    for g in ${(s.:.)prefix}; [[ -n "$g" ]] && ((pre_count++))
    for g in ${(s.:.)suffix}; [[ -n "$g" ]] && ((suf_count++))
    
    zeros_needed=$((8 - pre_count - suf_count))
    full_ip="$prefix"
    for ((i = 0; i < zeros_needed; i++)); do
      full_ip="${full_ip}:0000"
    done
    [[ -n "$suffix" ]] && full_ip="${full_ip}:$suffix"
  else
    full_ip="$ip"
  fi
  
  # Split into 8 groups
  local groups=(${(s.:.)full_ip})
  while (( $#groups < 8 )); do groups+=('0000'); done
  while (( $#groups > 8 )); do shift groups[-1]; done
  
  # Fully expanded (4 hex digits each)
  local full_groups=() padded
  for g in $groups; do
    g="${g#0}"
    [[ -z "$g" ]] && g=0
    printf -v padded '%04x' 0x${g}
    full_groups+=("$padded")
  done
  
  # Build string manually (no ${(j.:.)} bugs)
  local expanded="${full_groups[1]}"
  for ((i = 2; i <= 8; i++)); do
    expanded="${expanded}:${full_groups[i]}"
  done
  print "Expanded: $expanded"
  
  # Short groups (strip leading zeros)
  local short_groups=()
  for g in $full_groups; do
    while [[ "$g" == 0?* && "$g" != "0" ]]; do g="${g#0}"; done
    short_groups+=("$g")
  done
  
  # Canonical: longest zero run -> ::
  local best_start=-1 best_len=0 cur_start=-1 cur_len=0
  for ((i = 1; i <= 8; i++)); do
    if [[ "${short_groups[i]}" == "0" ]]; then
      [[ "$cur_start" == -1 ]] && cur_start=$((i-1))
      ((cur_len++))
    else
      [[ "$cur_len" -gt "$best_len" ]] && {
        best_len=$cur_len
        best_start=$cur_start
      }
      cur_start=-1
      cur_len=0
    fi
  done
  [[ "$cur_len" -gt "$best_len" ]] && {
    best_len=$cur_len
    best_start=$cur_start
  }
  
  local canonical
  if (( best_len > 1 )); then
    canonical=""
    for ((i = 1; i <= 8; i++)); do
      if (( i == best_start + 1 )); then
        canonical="${canonical}::"
        ((i = best_start + best_len))
        continue
      fi
      [[ -n "$canonical" && ${canonical[-1]} != ':' ]] && canonical="${canonical}:"
      canonical="${canonical}${short_groups[i]}"
    done
  else
    canonical="${short_groups[1]}"
    for ((i = 2; i <= 8; i++)); do
      canonical="${canonical}:${short_groups[i]}"
    done
  fi
  print "Canonical: $canonical"
  
  # Permutations
  print "Permutations:"
  local base="${short_groups[1]}"
  for ((i = 2; i <= 8; i++)); do
    base="${base}:${short_groups[i]}"
  done
  print "  $base"
  
  # Zero compression variants
  local start end len out
  for ((start = 0; start < 8; )); do
    [[ "${short_groups[start+1]}" != "0" ]] && { ((start++)); continue }
    
    end=$start
    while (( end < 8 )) && [[ "${short_groups[end+1]}" == "0" ]]; do
      ((end++))
    done
    
    for ((len = 2; len <= end - start; len++)); do
      out=""
      for ((i = 1; i <= start; i++)); do
        [[ -n "$out" ]] && out="${out}:"
        out="${out}${short_groups[i]}"
      done
      out="${out}::"
      for ((i = start + len + 1; i <= 8; i++)); do
        [[ -n "$out" && ${out[-1]} != ':' ]] && out="${out}:"
        out="${out}${short_groups[i]}"
      done
      print "  $out"
    done
    ((start = end))
  done
}
```